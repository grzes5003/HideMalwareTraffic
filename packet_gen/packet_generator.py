import abc
import logging
import ssl
import sys
from telnetlib import IP

import scapy
import socket

from scapy.layers.inet import TCP, UDP, TCP_client
from scapy.packet import Raw
from scapy.all import *

from enum import Enum
from dataclasses import dataclass, field

from packet_gen.PacketGeneratorBase import PacketGeneratorBase
from scapy.layers.l2 import Ether
from scapy.layers.tls.handshake import TLSClientHello, TLS13ClientHello


class Proto(Enum):
    TCP = 0
    UDP = 1


@dataclass
class ConnInfo:
    port: int
    tos: int
    Bytes: int
    load: float
    rate: float
    pkts: int
    addr: str = field(default='')
    proto: Proto = field(default=Proto.TCP)

    def __repr__(self):
        return f'{self.Bytes},{self.load},{self.rate},{self.pkts}'

    @classmethod
    def from_str(cls, _input: str, _port: int, _tos: int, _addr='', _proto=Proto.TCP):
        res = [float(val) for val in _input.split(',')]
        return ConnInfo(_port, _tos, Bytes=int(res[0]), load=res[1], rate=res[2], pkts=int(res[3]), addr=_addr,
                        proto=_proto)

    def get_target(self):
        return self.addr, self.port


class PacketGenerator(PacketGeneratorBase):
    @staticmethod
    def generate_client_packet(src_conn_info: ConnInfo, dst_conn_info: ConnInfo):
        assert len(dst_conn_info.addr) > 0, 'must specify destination address'

        context = ssl.create_default_context()
        context.check_hostname = False
        context.verify_mode = False

        init = Raw(load=str(dst_conn_info).encode())

        with socket.socket(socket.AF_INET,
                           socket.SOCK_STREAM if src_conn_info.proto == Proto.TCP else socket.SOCK_DGRAM, 0) as ss:
            ss.setsockopt(socket.IPPROTO_IP, socket.IP_TOS, src_conn_info.tos)
            with context.wrap_socket(ss) as s:
                s.connect(dst_conn_info.get_target())
                # sock = StreamSocket(s, Raw)
                s.send(raw(init))

                remaning_bytes = src_conn_info.Bytes - len(init)
                bytes_per_pkt = int(remaning_bytes / src_conn_info.pkts)

                for _ in range(src_conn_info.pkts):
                    msg = s.recv(4000)
                    logging.info(f'received: {msg}')

                    time.sleep(1/src_conn_info.rate)
                    s.send(os.urandom(bytes_per_pkt))
        logging.info(f'Finished connection')


if __name__ == '__main__':
    logging.basicConfig(format='%(asctime)s|%(name)s|%(levelname)s| %(message)s', level=logging.DEBUG)

    dst_addr = "192.168.0.234"
    src_addr = "192.168.0.234"
    src_port = 1239
    dst_port = 5051

    stos = 150
    dtos = 514

    src_bytes = 177
    dst_bytes = 173

    src_load = 4199
    dst_load = 4105

    src_rate = 5.898
    dst_rate = 5.898

    src_pkts = 2
    dst_pkts = 2

    proto = Proto.TCP
    src_info = ConnInfo(src_port, stos, src_bytes, src_load, src_rate, src_pkts, src_addr)
    dst_info = ConnInfo(dst_port, dtos, dst_bytes, dst_load, dst_rate, dst_pkts, dst_addr)

    PacketGenerator.generate_client_packet(src_info, dst_info)

    src_info.proto, dst_info.proto = Proto.UDP, Proto.UDP
    # PacketGenerator.generate_client_packet(src_info, dst_info)
