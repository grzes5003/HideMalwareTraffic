import abc
import logging
import sys
from telnetlib import IP

import scapy
import socket

from scapy.layers.inet import TCP, UDP, TCP_client
from scapy.packet import Raw
from scapy.all import *

from enum import Enum
from dataclasses import dataclass, field

from packet_gen.PacketGeneratorBase import PacketGeneratorBase
from scapy.layers.l2 import Ether
from scapy.layers.tls.handshake import TLSClientHello, TLS13ClientHello


class Proto(Enum):
    TCP = 0
    UDP = 1


@dataclass
class ConnInfo:
    port: int
    tos: int
    Bytes: int
    load: float
    rate: float
    pkts: int
    addr: str = field(default='')
    proto: Proto = field(default=Proto.TCP)

    def __repr__(self):
        return f'{self.Bytes},{self.load},{self.rate},{self.pkts}'

    def get_target(self):
        return self.addr, self.port


def chksum(msg):
    s = 0  # Binary Sum
    # loop taking 2 characters at a time
    for i in range(0, len(msg), 2):
        if (i + 1) < len(msg):
            a = ord(msg[i])
            b = ord(msg[i + 1])
            s = s + (a + (b << 8))
        elif (i + 1) == len(msg):
            s += ord(msg[i])
        else:
            raise "Something Wrong here"
    # One's Complement
    s = s + (s >> 16)
    s = ~s & 0xffff
    return s


class PacketGenerator(PacketGeneratorBase):
    @staticmethod
    def generate_client_packet123(src_conn_info: ConnInfo, dst_conn_info: ConnInfo):
        assert len(dst_conn_info.addr) > 0, 'must specify destination address'

        ip = IP(dst=dst_conn_info.addr, src=src_conn_info.addr, ttl=69, tos=123)

        SYN = ip / TCP(sport=src_conn_info.port, dport=dst_conn_info.port, flags="S", seq=0, options=[("MSS", 65495)])
        SYNACK = sr1(SYN, timeout=2)
        ACK = ip / TCP(sport=src_conn_info.port, dport=dst_conn_info.port, flags="A", seq=SYNACK.ack, ack=SYNACK.seq + 1)
        send(ACK)
        init = ip / TCP(sport=src_conn_info.port, dport=dst_conn_info.port, flags="P", seq=ACK.ack, ack=ACK.seq + 1, options=[("MSS", 65495)]) / \
               Raw(load=f"{dst_bytes},{dst_load},{dst_rate},{dst_pkts}".encode())
        send(init)

    @staticmethod
    def generate_client_packet(src_conn_info: ConnInfo, dst_conn_info: ConnInfo):
        assert len(dst_conn_info.addr) > 0, 'must specify destination address'

        ip = IP(dst=dst_conn_info.addr, src=src_conn_info.addr)
        init = Raw(load=f"{dst_bytes},{dst_load},{dst_rate},{dst_pkts}".encode())

        init.show2()
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            sock.connect(dst_conn_info.get_target())
            # sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 0)
            ss = StreamSocket(sock, IP)
            ss.send(init)
            # s = TCP_client.tcplink(IP, *dst_conn_info.get_target())
            # s.send(b"asdasdasd")
            data = b'string'
            sport = 4711  # arbitrary source port
            dport = 5050  # arbitrary destination port
            length = 8 + len(data)
            checksum = 0
            udp_header = struct.pack('!HHHH', sport, dport, length, checksum)
            # sock.sendto(raw(init), ("192.168.0.234", 5050))
            # sock.sendto(raw(init), ("192.168.0.234", 5050))

    @staticmethod
    def generate_client_packet321(src_conn_info: ConnInfo, dst_conn_info: ConnInfo):
        assert len(dst_conn_info.addr) > 0, 'must specify destination address'

        ip = IP(dst=dst_conn_info.addr, src=src_conn_info.addr, ttl=100)
        init = ip / TCP(sport=src_conn_info.port, dport=dst_conn_info.port) / \
               Raw(load=f"{dst_bytes},{dst_load},{dst_rate},{dst_pkts}".encode())

        init.show2()
        with socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP) as sock:
            sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)
            # sock.connect(dst_conn_info.get_target())
            # ss = StreamSocket(sock, IP)
            # ss.send(init)
            # s = TCP_client.tcplink(IP, *dst_conn_info.get_target())
            # s.send(b"asdasdasd")
            data = b'string'
            sport = 4711  # arbitrary source port
            dport = 5050  # arbitrary destination port
            length = 8 + len(data)
            checksum = 0
            udp_header = struct.pack('!HHHH', sport, dport, length, checksum)
            sock.sendto(raw(init), ("192.168.0.234", 5050))
            # sock.send(raw(init))

    @staticmethod
    def generate_client_packet3(src_conn_info: ConnInfo, dst_conn_info: ConnInfo):
        assert len(dst_conn_info.addr) > 0, 'must specify destination address'

        ip = IP(dst=dst_conn_info.addr, src=src_conn_info.addr, ttl=69)
        init = ip / UDP(sport=src_conn_info.port, dport=dst_conn_info.port) / \
               Raw(load=f"{dst_bytes},{dst_load},{dst_rate},{dst_pkts}".encode())

        init.show2()
        with socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW) as sock:
            sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)
            source_ip = '192.168.0.234'
            dest_ip = '192.168.0.234'  # or socket.gethostbyname('www.google.com')

            # ip header fields
            ip_ihl = 5
            ip_ver = 4
            ip_tos = 0
            ip_tot_len = 0  # kernel will fill the correct total length
            ip_id = 54321  # Id of this packet
            ip_frag_off = 0
            ip_ttl = 255
            ip_proto = socket.IPPROTO_TCP
            ip_check = 0  # kernel will fill the correct checksum
            ip_saddr = socket.inet_aton(source_ip)  # Spoof the source ip address if you want to
            ip_daddr = socket.inet_aton(dest_ip)

            ip_ihl_ver = (ip_ver << 4) + ip_ihl

            # the ! in the pack format string means network order
            ip_header = struct.pack('!BBHHHBBH4s4s', ip_ihl_ver, ip_tos, ip_tot_len, ip_id, ip_frag_off, ip_ttl, ip_proto,
                             ip_check, ip_saddr, ip_daddr)

            # tcp header fields
            tcp_source = 1234  # source port
            tcp_dest = 5050  # destination port
            tcp_seq = 454
            tcp_ack_seq = 0
            tcp_doff = 5  # 4 bit field, size of tcp header, 5 * 4 = 20 bytes
            # tcp flags
            tcp_fin = 0
            tcp_syn = 1
            tcp_rst = 0
            tcp_psh = 0
            tcp_ack = 0
            tcp_urg = 0
            tcp_window = socket.htons(5840)  # maximum allowed window size
            tcp_check = 0
            tcp_urg_ptr = 0

            tcp_offset_res = (tcp_doff << 4) + 0
            tcp_flags = tcp_fin + (tcp_syn << 1) + (tcp_rst << 2) + (tcp_psh << 3) + (tcp_ack << 4) + (tcp_urg << 5)

            # the ! in the pack format string means network order
            tcp_header = struct.pack('!HHLLBBHHH', tcp_source, tcp_dest, tcp_seq, tcp_ack_seq, tcp_offset_res, tcp_flags,
                              tcp_window, tcp_check, tcp_urg_ptr)

            user_data = b'Hello, how are you'

            # pseudo header fields
            source_address = socket.inet_aton(source_ip)
            dest_address = socket.inet_aton(dest_ip)
            placeholder = 0
            protocol = socket.IPPROTO_TCP
            tcp_length = len(tcp_header) + len(user_data)

            psh = struct.pack('!4s4sBBH', source_address, dest_address, placeholder, protocol, tcp_length);
            psh = psh + tcp_header + user_data

            tcp_check = checksum(psh)
            # print tcp_checksum

            # make the tcp header again and fill the correct checksum - remember checksum is NOT in network byte order
            tcp_header = struct.pack('!HHLLBBH', tcp_source, tcp_dest, tcp_seq, tcp_ack_seq, tcp_offset_res, tcp_flags,
                              tcp_window) + struct.pack('H', tcp_check) + struct.pack('!H', tcp_urg_ptr)

            # final full packet - syn packets dont have any data
            packet = ip_header + tcp_header + user_data

            sock.sendto(packet, (dest_ip, 5050))
            print('all packets send')

    @staticmethod
    def generate_client_packet123(src_conn_info: ConnInfo, dst_conn_info: ConnInfo):
        # packet = Ether() / IP(dst=target[0], tos=stos) / TCP(dport=target[1], flags='S')
        assert len(dst_conn_info.addr) > 0, 'must specify destination address'

        # self.sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)
        # self.sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)
        with socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_IP) as sock:
        # with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            # send init to server
            init = IP(dst=dst_conn_info.addr) / \
                   (TCP(sport=src_conn_info.port, dport=dst_conn_info.port, options=[("MSS", 65495)]) if src_conn_info.proto == Proto.TCP
                    else UDP(sport=src_conn_info.port, dport=dst_conn_info.port)) / \
                   Raw(load=f"{dst_bytes},{dst_load},{dst_rate},{dst_pkts}".encode())
            sock.connect(dst_conn_info.get_target())
            ssock = StreamSocket(sock)
            # ssock.send(init)
            # init = raw(init)

            sock.send(b'asdasd')

            # send(init)
            logging.info(f'and now {init}')

            src_conn_info.pkts -= 1
            src_conn_info.Bytes -= len(init)

            for idx in range(src_conn_info.pkts):
                pass

    def generate_server_packet(self):
        pass


if __name__ == '__main__':
    logging.basicConfig(format='%(asctime)s|%(name)s|%(levelname)s| %(message)s', level=logging.DEBUG)

    dst_addr = "192.168.0.234"
    src_addr = "192.168.0.234"
    src_port = 1239
    dst_port = 5050

    stos = 150
    dtos = 514

    src_bytes = 177
    dst_bytes = 173

    src_load = 4199
    dst_load = 4105

    src_rate = 5.898
    dst_rate = 5.898

    src_pkts = 2
    dst_pkts = 2

    proto = Proto.TCP
    src_info = ConnInfo(src_port, stos, src_bytes, src_load, src_rate, src_pkts, src_addr)
    dst_info = ConnInfo(dst_port, dtos, dst_bytes, dst_load, dst_rate, dst_pkts, dst_addr)

    PacketGenerator.generate_client_packet(src_info, dst_info)
