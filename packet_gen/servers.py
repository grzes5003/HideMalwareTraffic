import ssl
import time

from scapy.compat import raw
from scapy.packet import Raw
from scapy.supersocket import StreamSocket

from packet_gen.ServerBase import ServerBase
from packet_gen.packet_generator import ConnInfo, Proto
from select import select
import logging
import socket


class Server(ServerBase):
    def __init__(self, addr, port):
        self.addr = addr
        self.port = port
        self.connections = {}
        self.SOCK_SIZE = 8000

        self.context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
        self.context.load_cert_chain(certfile='cert\\server.crt', keyfile='cert\\server.key', password='1234')

    def __enter__(self):
        self.udp_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.udp_sock.bind((self.addr, self.port))

        self.tcp_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.tcp_sock.bind((self.addr, self.port))
        self.tcp_sock.listen()

        logging.info(f'Started listening on {self.addr}:{self.port}')

        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.tcp_sock.close()

    def handle_tcp(self):
        with self.context.wrap_socket(self.tcp_sock, server_side=True) as ssock:
            conn, addr = ssock.accept()
            tos = conn.getsockopt(socket.IPPROTO_IP, socket.IP_TOS)
            with conn:
                logging.info(f'Connected by {addr}')
                sock = StreamSocket(conn, Raw)
                data = sock.recv(self.SOCK_SIZE)
                logging.debug(f'received tcp: "{data.load}"')
                dst_info = ConnInfo.from_str(data.load.decode("utf-8"), addr[1], tos, addr[0], _proto=Proto.TCP)

                bytes_per_pkt = int(dst_info.Bytes / dst_info.pkts)

                for _ in range(dst_info.pkts):
                    sock.send(Raw(load='data'.encode()))
                    # logging.debug(f'received tcp {dst_info.pkts}th: "{msg.load.decode("utf-8")}"')
                    sock.recv(self.SOCK_SIZE)
                    time.sleep(1 / dst_info.rate)

    def handle_udp(self):
        msg, addr = self.udp_sock.recvfrom(self.SOCK_SIZE)
        logging.info(f'Connected by {addr}')
        logging.debug(f'received udp: "{msg}"')
        dst_info = ConnInfo.from_str(msg.decode("utf-8"), addr[1], 123, addr[0], _proto=Proto.UDP)
        while dst_info.pkts > 0:
            self.udp_sock.sendto(b'data', addr)
            msg = self.udp_sock.recv(self.SOCK_SIZE)
            logging.debug(f'received udp {dst_info.pkts}th: "{msg.decode("utf-8")}"')
            dst_info.pkts -= 1

    def handle_connections(self):
        input_sock = [self.udp_sock, self.tcp_sock]
        while True:
            inputready, outputready, exceptready = select(input_sock, [], [])

            for s in inputready:
                if s == self.tcp_sock:
                    self.handle_tcp()
                elif s == self.udp_sock:
                    self.handle_udp()
                else:
                    logging.error(f'unknown socket type {s}')


class SSlServer:
    def __init__(self, addr, port):
        self.addr = addr
        self.port = port
        self.connections = {}
        self.SOCK_SIZE = 8000

        self.context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
        self.context.load_cert_chain(certfile='cert\\server.crt', keyfile='cert\\server.key', password='1234')

    def __enter__(self):
        self.tcp_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.tcp_sock.bind((self.addr, self.port))
        self.tcp_sock.listen()

        self.ssl_sock = self.context.wrap_socket(self.tcp_sock, server_side=True)
        logging.info(f'Started listening on {self.addr}:{self.port}')

        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.ssl_sock.close()
        self.tcp_sock.close()

    def handle_tcp(self):
            conn, addr = self.ssl_sock.accept()
            tos = conn.getsockopt(socket.IPPROTO_IP, socket.IP_TOS)
            with conn:
                logging.info(f'Connected by {addr}')
                data = conn.recv(self.SOCK_SIZE)
                logging.debug(f'received tcp: "{data}"')
                dst_info = ConnInfo.from_str(data.decode("utf-8"), addr[1], tos, addr[0], _proto=Proto.TCP)

                bytes_per_pkt = int(dst_info.Bytes / dst_info.pkts)

                for _ in range(dst_info.pkts):
                    conn.send(b'data')
                    # logging.debug(f'received tcp {dst_info.pkts}th: "{msg.load.decode("utf-8")}"')
                    conn.recv(self.SOCK_SIZE)
                    time.sleep(1 / dst_info.rate)
            conn.close()
            logging.info(f'Finished connection')

    def handle_connections(self):
        while True:
            self.handle_tcp()


if __name__ == '__main__':
    logging.basicConfig(format='%(asctime)s|%(name)s|%(levelname)s| %(message)s', level=logging.DEBUG)
    src_target = ('192.168.0.234', 5051)
    # server = Server(*src_target)
    server = SSlServer(*src_target)
    with server as srv:
        while True:
            srv.handle_connections()

